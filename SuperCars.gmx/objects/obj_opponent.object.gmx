<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_opponentcar</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_car</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// http://www.chaseofbass.com/game-tutorial-top-down-racing-ai-opponents-example/


//NOTE: Starting direction of car determined in room creation code

direction=180; //start with the direction you want your car to face
image_angle=direction; //start image facing direction

acceleration=.5; //rate of accelerationeration
deceleration=.04; //rate of decelerationeration
maxspeed=4 //maximum speed of the car
turnspeed=20 //value of car’s steering in degrees

nextspeed=4; //a variable that randomly picks a speed to drive

currentnode=0; //this variable will be used as a placeholder for the node the car will drive towards
nodenudge_x=0; //we will use this variable later to shift the position the car drives towards on the x axis
nodenudge_y=0; //we will use this variable later to shift the position the car drives towards on the y axis

alarm[0]=4; //events in this alarm change the speed of our ‘nextspeed’ variable

directionCorrectionSpeed = 2;


//Choosing a path for our car to follow

/*
since we have multiple levels and want to use
the same object for each level we can pick a path
based on the room that object AIcar is in
*/

currentpath=pth_testTrack; //set this to the path you created

maxpathpoints=path_get_number(currentpath); //maxpathpoints will store the number of points in currentpath

//now let’s convert our path to locations in an 2d array to make it easier to work with

for (i=0;i&lt;maxpathpoints;i++) //for loop will do this for each point in the path
{
nodearay[i,0]= path_get_point_x(currentpath,i); //x location of first path point
nodearay[i,1]= path_get_point_y(currentpath,i); //y location of first path point
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
CREDIT:
These next two lines are based on a code originally posted by Nocturne on an older thread -brilliant stuff!
Basically it’s a condensed method of approaching the new angle smoothly…
*/

var wantedDirection = (direction+(sin(degtorad(point_direction(x,y,nodearay[currentnode,0]+nodenudge_x,nodearay[currentnode,1]+nodenudge_y)-direction))*turnspeed));  //I can’t even explain this magic
image_angle=(image_angle+(sin(degtorad(wantedDirection-image_angle))*turnspeed)); //this will turn the angle of the image towards the chosen direction

if(applyNudge)
{
    var vxSpeed = lengthdir_x(speed, direction);
    var vySpeed = lengthdir_y(speed, direction);
    var vxNudge = lengthdir_x(nudgeSpeed, nudgeDirection);
    var vyNudge = lengthdir_y(nudgeSpeed, nudgeDirection);
    
    var directionAfterNudge = ((speed * direction) + (nudgeSpeed * nudgeDirection)) / (speed + nudgeSpeed);
    direction = directionAfterNudge;
    //TODO: Decrease nudge speed;


    var directionCorrectionSign = 1;
    var differenceInDirection = min(abs(wantedDirection - direction), abs(direction - wantedDirection));
    differenceInDirection = wantedDirection - direction;
    
    //Our direction has been changed because of a collision, find out if we need to turn clockwise (-1) or counterclockwise (1) to reach our wanted direction
    if(differenceInDirection &gt;= 0)
    {
        if(differenceInDirection &lt;= 180)
        {
            directionCorrectionSign = 1;
        }
        else
        {
            directionCorrectionSign = -1;
        }
    }
    else
    {
        if(differenceInDirection &lt;= 180)
        {
            directionCorrectionSign = -1;
        }
        else
        {
            directionCorrectionSign = 1;
        }
    }
    
    // If we cannot reach the wanted direction within 1 correctionstep then apply the full correctionstep
    if(differenceInDirection &gt; directionCorrectionSpeed)
    {
        direction = direction + (directionCorrectionSign * directionCorrectionSpeed);
    }
    else
    {
        direction = wantedDirection;
        nudgeDirection = 0;
        nudgeSpeed = 0;

    }
}
else
{
    direction = wantedDirection;
    nudgeDirection = 0;
    nudgeSpeed = 0;
    applyNudge = 0;
}


//Next we tell the car to speed up or down in relation to the value of our variable ‘nextspeed’ -which is set in the alarm 0 event

if speed &lt; nextspeed //is the speeed less than the next speed?
{
    speed+=acceleration; //then speed up at our rate of acceleration
}
else if speed &gt; nextspeed //going faster than next speed?
{
    speed-=deceleration; //slow down at our rate of deceleration
}


//DRIVING
/*
So the idea here is to pick a node and driving towards it
so we reference the array we made in the create event
and when we reach a distance to that point we change the focus onto the next point
through the use of our variable ‘currentnode’
*/


if currentnode = maxpathpoints -1  //first we make sure we limit currentnode to the max number of nodes
{
    currentnode=0; //if it’s maxed out then we loop back to the first node -this is a great place to add a lap count.
}

if distance_to_point(nodearay[currentnode,0],nodearay[currentnode,1]) &lt; 16 //check distance to node
{
    currentnode+=1; //move on to next node
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_opponent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//scr_set_speed_after_collision(self, other);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
